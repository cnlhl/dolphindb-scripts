def feature_gen(transtb,ordertb,depthtb,limitations) {
    tb = select DepthMarketTime as MarketTime from depthtb
    update tb set feature = rand(100,size(tb.MarketTime))
    result = tb
    return result
}

def each_return(time0,time1){ return (ratio(time1,time0)-1)}

defg each_return_by_count(price,return_intervals){ return ratio(price[return_intervals],price[0])-1 }

def return_gen_by_depth(depthtb,limitations){
    if(limitations["frenquency"]==3s){
        tb = select DepthMarketTime as MarketTime,(AskPrice1+BidPrice1)/2 as Price from depthtb
    }else{
        tb = select (last(AskPrice1)+last(BidPrice1))/2 as Price from depthtb group by interval(DepthMarketTime,limitations["frequency"],"prev",closed = "right",label = "right") as MarketTime
    }
    tb = select * from tb where MarketTime >= limitations["start_time"] 
    // update tb set StockReturn = eachPost(each_return,Price,Price[-1])
    update tb set StockReturn = window(each_return_by_count,(Price,limitations["return_intervals"]),0:limitations["return_intervals"])
    return tb
}

def return_gen(transtb,limitations){
    tb = select * from transtb where CancelFlag = "F"
    tb = select last(Price)as Price from tb group by interval(TransactionTime,limitations["frequency"],"prev",closed = "right",label = "right") as MarketTime
    tb = select * from tb where MarketTime >= limitations["start_time"] and MarketTime <= limitations["end_time"]
    update tb set StockReturn = eachPost(each_return,Price,Price[-1])
    return tb
}

def R_gen(t, method){
    if(method == "UP"){
        ct = select * from t where StockReturn>=0
    }else if(method == "DOWN"){
        ct = select * from t where StockReturn<0
    }else{
        ct = t
    }
    res = ols(ct.StockReturn,ct.feature,1,2)
    ic = corr(ct.StockReturn,ct.feature)
    return res["RegressionStat"]["statistics"][0],ic,ct
}

def load_3tables(target_date,target_stock){
    depthtb = loadTable("dfs://stock_history","depthBook")
    ordertb = loadTable("dfs://stock_history","orderBook")
    transtb = loadTable("dfs://stock_history","transBook")
    depth_d = select * from depthtb where Date = target_date and StockCode = target_stock
    trans_d = select * from transtb where Date = target_date and StockCode = target_stock
    order_d = select * from ordertb where Date = target_date and StockCode = target_stock
    return depth_d,trans_d,order_d
}

def feature_selection(feature_file,target_stock, target_date ,limitations){
    if(limitations["file_flag"] == 1 ){
        depth_d,trans_d,order_d = load_3tables(target_date,target_stock[1:])
        feature_tb = select * from feature_file where date(Timestamp) = target_date
        feature_tb = table(time(feature_tb["Timestamp"]) as MarketTime,feature_tb[target_stock] as feature)
    }else{
        depth_d,trans_d,order_d = load_3tables(target_date,target_stock)
        feature_tb = feature_gen(trans_d,order_d,depth_d,limitations)
    }
    feature_tb = select * from feature_tb where MarketTime <= 11:30:00 or MarketTime >= 13:00:00 and feature is not null
    return feature_tb,depth_d,trans_d,order_d
}

def match_table_process(target_date,target_stock,feature_tb,return_tb,limitations){
    match_tb = select * from feature_tb left join return_tb on feature_tb.MarketTime = return_tb.MarketTime 
    match_tb = select concatDateTime(target_date,MarketTime) as Timestamp, feature, Price, StockReturn from match_tb where MarketTime >= limitations["start_time"] and MarketTime <= limitations["end_time"]
    update match_tb set StockCode = regexReplace(target_stock,"[a-z]","")
    match_tb.reorderColumns!(["Timestamp","StockCode","feature","Price","StockReturn"])
    return match_tb
}

def R_square(feature_file,target_stock, target_date ,limitations){
    feature_tb,depth_d,trans_d,order_d = feature_selection(feature_file,target_stock, target_date ,limitations)
    return_tb = return_gen_by_depth(depth_d,limitations)
    match_tb = match_table_process(target_date,target_stock,feature_tb,return_tb,limitations)

    try{
        return R_gen(match_tb,limitations["method"])
    }catch(ex){
        print("error when processing stock: "+target_stock)
        print("detail:",ex)
    }
}

def loop_caculate(feature_file,limitations,stocks){
    trading_days = getMarketCalendar('SSE', limitations["start_date"], limitations["end_date"])

    print(trading_days)
    res = table(1:0,["Date","Stock","R","Correlation"],[DATE,SYMBOL,DOUBLE,DOUBLE])
    feature = table(1:0,["Timestamp","StockCode","Feature","Price","StockReturn"],[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE])

    for(current_day in trading_days){
        for(stock in stocks){
            temp_res = R_square(feature_file,stock,current_day,limitations)
            feature.append!(temp_res[2])
            insert into res values(current_day,regexReplace(stock,"[a-z]",""),temp_res[0],temp_res[1])
        }
    }
    return res,feature
}

def process_datetime(start_date_str, end_date_str, start_time_str, end_time_str,frequency_str,return_intervals_str,method,file_flag){
    start_date = temporalParse(start_date_str,"yyyy.MM.dd")
    end_date = temporalParse(end_date_str,"yyyy.MM.dd")
    start_time = temporalParse(start_time_str,"HH:mm:ss")
    end_time = temporalParse(end_time_str,"HH:mm:ss")
    frequency = duration(frequency_str)
    return_intervals_time = duration(return_intervals_str)
    return_intervals_count = int(return_intervals_time)/int(frequency)
    limitations = dict(["start_date","end_date","start_time","end_time","return_intervals","frequency","file_flag","method"],[start_date,end_date,start_time,end_time,return_intervals_count,frequency,file_flag,method])
    return limitations
}

def args_test(limitations,timestamps){
    try{   
        start_time = first(timestamps)
        end_time = last(timestamps)
        if (date(start_time)>limitations["start_date"] or date(end_time)<limitations["end_date"])
            throw "error: Start/end date range is too large"
    }catch(ex){
        print(ex)
    }
}

def readfile_caculate(filepath,start_date_str, end_date_str, start_time_str, end_time_str,frequency,return_intervals,method){
    feature_file = loadText(filename = filepath, containHeader = true)
    file_header = columnNames(feature_file)
    stocks = file_header[1:]
    limitations = process_datetime(start_date_str, end_date_str, start_time_str, end_time_str,frequency, return_intervals,method,1)
    args_test(limitations,feature_file[file_header[0]])
    return loop_caculate(feature_file,limitations,stocks)
}

def setting_caculate(stocks, start_date_str, end_date_str, start_time_str, end_time_str, frequency,return_intervals,method){
    limitations = process_datetime(start_date_str, end_date_str, start_time_str, end_time_str,frequency,return_intervals, method,0)
    return loop_caculate(,limitations,stocks)
}

test,feature = readfile_caculate("/home/lilh/feature1.csv","2022.09.01","2022.09.30","09:30:00","15:00:00","3s","30s","ALL")
// test,feature = setting_caculate(["000001","000002"],"2023.01.04","2023.02.04","09:00:00","15:00:00","3s","ALL")